%!TEX root = ../dissertation.tex
\chapter{Introduction}
\label{introduction}

\newthought{Privacy-preserving computation}, or secure computation,
is an extension of traditional cryptography to protect users' sensitive information and metadata during computation.

In contrast to traditional cryptographic tasks, where cryptography is used to ensure the security and integrity of communication or storage, and the adversary is typically an outsider attempting to eavesdrop on the communication between sender and receiver, the cryptography used in the privacy-preserving computation is designed to also safeguard the privacy of the participants from one another.

Specifically, privacy-preserving computation allows multiple parties to jointly compute a function without revealing their inputs and it has numerous applications in various fields, including finance, healthcare, and data analysis. It allows for collaboration and data sharing without compromising the privacy of sensitive data, which is becoming increasingly important in today's digital age.
For a concrete example, imagine a medical center that holds a potentially vast database of disease-associated genetic variants. A patient wants to undergo a DNA screening to check for any issues. However, due to privacy concerns, the patient is hesitant to provide their DNA in plain form. This is where privacy-preserving computation comes into play. Both parties (the medical center and the patient) can cooperatively execute a secure protocol, allowing the patient to learn if they have any genetic markers associated with diseases without revealing additional confidential information about their DNA.

\subsubsection{Motivation}
% While privacy-preserving computation has gained significant attention in recent times due to its strong security and numerous potential applications, its efficiency remains its Achilles' heel. Privacy-preserving protocols require significantly higher computational overhead and communicational bandwidth when compared to baseline (i.e., insecure) protocols.

Despite the burgeoning interest and potential applications associated with privacy-preserving computation, owing to its robust security, the \emph{efficiency} of such protocols continues to be a challenge. Privacy-preserving protocols require significantly higher computational overhead and bandwidth when compared to baseline (i.e., insecure) protocols.

As an example, consider the secure computation functionality of the set intersection (i.e., private set intersection), which is one of the most popular applications of privacy-preserving computation. In this scenario, Alice possesses a large dataset $A$, while Bob holds a much smaller dataset $B$ such that $|B| \ll |A|$. Alice wants to determine if there is any intersection between their datasets without learning anything about Bob's dataset or revealing any information about her own.

The baseline protocol for set intersection involves Bob sending his dataset in plain text, which Alice then compares to her own dataset to identify any common elements. Note that this approach entails $O(|B|)$ communication bandwidth, which is inherent to this method.

In contrast, secure computation protocols usually entail $O(|A|+|B|)$ communication bandwidth. While it ensures that the privacy of both parties is protected, and no information is revealed to either party beyond what is necessary for the set intersection computation, this approach incurs a prohibitively higher communication cost if $|A|$ is super large. For instance, a DNS server holding a $100$ GB set with each entry $4$ Bytes is a normal case but $100$ GB communication bandwidth is highly undesired!

It is important to note that the efficiency gap between traditional and secure computation protocols is not just limited to asymptotic measures but is also evident in concrete scenarios. For example, consider a basic functionality (i.e., oblivious transfer) where a receiver holds a bit $b \in \bits$ and a sender holds two bits $x_0$ and $x_1$. The goal is for the receiver to learn $x_b$ while remaining ignorant of $x_{1-b}$, and the sender must not know anything about the value of $b$. Baseline insecure protocols only require a bandwidth of \emph{two bits}, while secure protocols often require two ciphertexts, each with a size of approximately \emph{512} bits if implemented using the most efficient 256-bit elliptic curves.

Therefore, finding ways to minimize the overhead (whether it be in terms of computation or communication, asymptotically or concretely) while maintaining security in a reasonable manner remains an exciting problem to work on.

This thesis is centred around enhancing efficiency and reducing the costs of communication and computation for commonly used privacy-preserving primitives.
We tackled several problems in privacy-preserving computation, the first of which involves multiparty threshold private set intersection (PSI).
For threshold PSI, the parties involved in the protocol learn the output if the size of the intersection between the input sets of the parties is very large, say larger than $n-t$, where $n$ is the size of the input sets and $t$ is some \emph{threshold} such that $t\ll n$; Otherwise, they learn nothing about the intersection. This is in contrast with standard PSI where the parties always get the intersection, no matter its size.
The main reason for considering this problem (apart from its numerous applications like ride-sharing, contact discovery etc.) is that the amount of communication needed is much smaller than for standard PSI: In particular, there are threshold PSI protocols whose communication complexity depends only on the threshold $t$ and not on the size of the input sets as for standard PSI \cite{C:GhoSim19} in two-party setting. 
However, non-trivial threshold PSI protocols in the multiparty setting are still an open question to solve. Because if someone naively extends \cite{C:GhoSim19} to a multiparty setting then the bandwidth \emph{for each participant} will depend on the number of parties which is prohibitively expensive.

The second problem we investigated is unbalanced PSI, as briefly mentioned at the outset. In this scenario, two parties aim to compute the intersection of their respective sets, but one set significantly outnumbers the other in terms of its size. Solving this problem led us to initiate the study of laconic PSI: Laconic PSI allows a receiver to send a short digest of its \emph{large} data set, which in turn can be used by potentially many different senders to compute a PSI second-round message. We require  that the total communication complexity as well as the sender's running time be independent of the receiver's input size. Though a non-black-box approach is known via general purpose laconic function evaluation~\cite{FOCS:QuaWeeWic18}, we are interested in providing a \emph{black-box} solution for efficiency concern.
The black-box solution refers to the construction without using any explicit circuit-level description of cryptographic primitives. Particularly, we consider constructions which compute cryptographic primitives inside garbled circuits or express statements in terms of NP-complete languages as non-black-box approaches, which are notably demanding, resulting in either substantial computational costs or significant communication overheads.

The third problem we addressed concerns the rate of oblivious transfer (OT).  In most applications, one OT is not enough and it is required to perform many OT operations in parallel.
We let $n$ denote the number of parallel executions. Various techniques have been developed to address this task of \emph{batch-OT} \cite{C:IKNP03,C:BCGIKS19,CCS:BCGIKRS19}. For the most part, they involve a preprocessing ``offline'' phase where the parties generate random OT correlations. Given such correlations, executing the OT protocol in the so-called ``online phase'' is computationally very simple. This approach is very useful for purposes of computational efficiency since the offline phase can be carried out even before the actual inputs of the computation are known. However, in terms of communication complexity, there is an inherent cost, even just in the online phase, of $n$ receiver bits and $2n$ sender bits. In contrast, the insecure implementation only requires $n$ bits to be sent from each party in a two-message protocol: the receiver sends its input, and the sender returns all of the appropriate $x_b$ values. As always in cryptography, we wish to understand what is the ``cost of privacy'', namely how closely can we approach the information-theoretic minimum without losing privacy. 

The final problem we addressed pertains to \emph{stealth signatures}, which we introduced in the following manner.
In this scenario, the receiver generates a master key pair and disseminates the master public key. Any sender can then \emph{locally re-randomize} this master public key into a one-time public key. For any external observer, this one-time public key is \emph{unlinkable} to the master public key. However, when the receiver has access to the master secret key, it can \emph{link} this one-time public key to its master public key, and also generate the corresponding one-time secret key locally, on-the-fly. Utilizing this one-time secret key, the receiver can sign messages without revealing its metadata, meaning that an external observer will not be able to ascertain which public key matches the signature.
It's important to note in this mechanism, the receiver only needs to broadcast its master public key, and \emph{does not} need to distribute a distinct unlinkable one-time public key for each potential sender. Given that the number of senders could potentially reach hundreds or thousands, this feature offers significant benefits. This mechanism is extensively employed in privacy-preserving cryptocurrencies such as Monero, and also has applications in passwordless authentication as defined in the Fast IDentity Online (FIDO) standard.
However, the current known protocols for this mechanism are either insecure in some reasonable adversarial models or inefficient in practical implementation.

At the end of the introduction,
this thesis is organized as follows:
\subsubsection{Contributions and roadmaps}
\begin{itemize}
    \item In \cref{sec:prelim}, we provide essential preliminaries about basic cryptography primitives, security definitions or frameworks, well-established assumptions, lattices, polynomials, and some statistical tools.
    \item In \cref{sec:threshpsi}, we present a protocol of multiparty threshold private set intersection, which improves communication bandwidth \emph{for each party} from $\tilde{O}(Nt^2)$ to $\tilde{O}(t^2)$ where $N$ is the number of parties and $t$ the threshold while retaining the same computational overhead and security level.
    \item In \cref{sec:laconicpsi}, we introduce a new primitive, laconic private set intersection, which solves unbalanced PSI in a non-interactive way while making communication bandwidth as succinct as possible. Specifically, after the server publishes a short digest of constant size, any client can non-interactively send its message of size independent of the server's dataset.
    \item In \cref{sec:r1ot}, we present a two-message oblivious transfer protocol which has asymptotically minimum communicational bandwidth, namely, to transfer $n$ bits information, it only requires $n(1+o(1))$ bits bandwidth for each user while retaining computational efficiency. We also show how to efficiently emulate $\ZZ_2$ inside a prime-order group $\ZZ_p$ in a function-private manner.
    \item In \cref{sec:ssig}, we present a post-quantum privacy-preserving signature called stealth signature that saves ~$70\%$ bandwidth compared to the state of the art while  achieving the strongest security. Additionally, we present a fuzzy variant which protects users' metadata and improves the server's computational work from $O(N)$ to $O(\sqrt{N})$ where $N$ is the number of users.
    \item In \cref{conclusion}, we summarise the thesis in a coherent and concise way.
\end{itemize}
